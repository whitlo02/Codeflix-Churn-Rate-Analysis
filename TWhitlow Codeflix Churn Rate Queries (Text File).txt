Task 1 Query:Select * From subscriptionsLimit 100;Query 1 Results: (only provided sample of 20 of the 100 results displayed)idsubscription_startsubscription_endsegment12016-12-012017-02-018722016-12-012017-01-248732016-12-012017-03-078742016-12-012017-02-128752016-12-012017-03-098762016-12-012017-01-198772016-12-012017-02-038782016-12-012017-03-028792016-12-012017-02-1787102016-12-012017-01-0187112016-12-012017-01-1787122016-12-012017-02-0787132016-12-0130142016-12-012017-03-0730152016-12-012017-02-2230162016-12-0130172016-12-0130182016-12-022017-01-2987192016-12-022017-01-1387202016-12-022017-01-1587How many different segments do you see? Two, segments 30 and 87.Task 2 Query:Select MIN(subscription_start)From subscriptions; Select Max(subscription_start)From subscriptions;Query 2 Results:MIN(subscription_start)2016-12-01Max(subscription_start)2017-03-30Which months will you be able to calculate churn for?You can calculate churn for January 2017, February 2017, March 2017.Task 3 Query:WITH months AS (SELECT	'2017-01-01' AS first_day,  '2017-01-31' AS last_day UNION Select 	'2017-02-01' AS first_day,  '2017-02-28' AS last_day UNION Select	'2017-03-01' AS first_day,  '2017-03-31' AS last_day) Select * From months;Query 3 Results:first_daylast_day2017-01-012017-01-312017-02-012017-02-282017-03-012017-03-31Task 4 Query :WITH months AS (SELECT      '2017-01-01' AS first_day,      '2017-01-31' AS last_day UNION Select       '2017-02-01' AS first_day,      '2017-02-28' AS last_day UNION Select      '2017-03-01' AS first_day,      '2017-03-31' AS last_day), cross_join AS  (SELECT * FROM subscriptions  Cross JOIN months) Select * From cross_join Limit 10;Query 4 Results: (Only provided 10 samples due to size of table)idsubscription_startsubscription_endsegmentfirst_daylast_day12016-12-012017-02-01872017-01-012017-01-3112016-12-012017-02-01872017-02-012017-02-2812016-12-012017-02-01872017-03-012017-03-3122016-12-012017-01-24872017-01-012017-01-3122016-12-012017-01-24872017-02-012017-02-2822016-12-012017-01-24872017-03-012017-03-3132016-12-012017-03-07872017-01-012017-01-3132016-12-012017-03-07872017-02-012017-02-2832016-12-012017-03-07872017-03-012017-03-3142016-12-012017-02-12872017-01-012017-01-31Task 5 Query:WITH months AS (SELECT      '2017-01-01' AS first_day,      '2017-01-31' AS last_day UNION Select       '2017-02-01' AS first_day,      '2017-02-28' AS last_day UNION Select      '2017-03-01' AS first_day,      '2017-03-31' AS last_day), cross_join AS  (SELECT * FROM subscriptions  Cross JOIN months ),status AS(Select id, first_day AS month, CASE      WHEN (subscription_start < first_day) AND         (subscription_end >   first_day OR subscription_end IS NULL) AND (segment = 87) THEN 1      ELSE 0 END AS is_active_87,  CASE      WHEN (subscription_start < first_day) AND (subscription_end > first_day OR subscription_end IS NULL) AND (segment = 30) Then 1      ELSE 0 END AS is_active_30From cross_join) Select * From status Limit 5;Query 5 results: (Limited to 5 samples due to size of table)idmonthis_active_87is_active_3012017-01-011012017-02-010012017-03-010022017-01-011022017-02-0100Task 6 Query:WITH months AS (SELECT      '2017-01-01' AS first_day,      '2017-01-31' AS last_day UNION Select       '2017-02-01' AS first_day,      '2017-02-28' AS last_day UNION Select      '2017-03-01' AS first_day,      '2017-03-31' AS last_day), cross_join AS  (SELECT * FROM subscriptions  Cross JOIN months ),status AS(Select id, first_day AS month, CASE      WHEN (subscription_start < first_day) AND         (subscription_end >   first_day OR subscription_end IS NULL) AND (segment = 87) THEN 1      ELSE 0 END AS is_active_87,  CASE      WHEN (subscription_start < first_day) AND (subscription_end > first_day OR subscription_end IS NULL) AND (segment = 30) Then 1      ELSE 0 END AS is_active_30, CASE      WHEN (subscription_end BETWEEN first_day AND last_day)      AND (segment = 87) Then 1     ELSE 0END AS is_canceled_87,CASE      WHEN (subscription_end BETWEEN first_day AND last_day) AND (segment = 30) Then 1     ELSE 0END AS is_canceled_30From cross_join)Select * From status Limit 5;Query 6 results: (Sample of 5 provided due to table size)idmonthis_active_87is_active_30is_canceled_87is_canceled_3012017-01-01100012017-02-01001012017-03-01000022017-01-01101022017-02-010000Query 7 Task:WITH months AS (SELECT      '2017-01-01' AS first_day,      '2017-01-31' AS last_day UNION Select       '2017-02-01' AS first_day,      '2017-02-28' AS last_day UNION Select      '2017-03-01' AS first_day,      '2017-03-31' AS last_day), cross_join AS  (SELECT * FROM subscriptions  Cross JOIN months ),status AS(Select id, first_day AS month, CASE      WHEN (subscription_start < first_day) AND         (subscription_end >   first_day OR subscription_end IS NULL) AND (segment = 87) THEN 1      ELSE 0 END AS is_active_87,  CASE      WHEN (subscription_start < first_day) AND (subscription_end > first_day OR subscription_end IS NULL) AND (segment = 30) Then 1      ELSE 0 END AS is_active_30, CASE      WHEN (subscription_end BETWEEN first_day AND last_day)      AND (segment = 87) Then 1     ELSE 0END AS is_canceled_87,CASE      WHEN (subscription_end BETWEEN first_day AND last_day) AND (segment = 30) Then 1     ELSE 0END AS is_canceled_30From cross_join ), status_aggregate AS (SELECT    month,  SUM(is_active_87) AS sum_active_87,  SUM(is_active_30) AS sum_active_30,  SUM(is_canceled_87) AS sum_canceled_87,  SUM(is_canceled_30) AS sum_canceled_30  FROM status   Group BY month  ) Select * From status_aggregate;Query 7 Results: monthsum_active_87sum_active_30sum_canceled_87sum_canceled_302017-01-0127829170222017-02-01462518148382017-03-0153171625884Query 8 Task:WITH months AS (SELECT      '2017-01-01' AS first_day,      '2017-01-31' AS last_day UNION Select       '2017-02-01' AS first_day,      '2017-02-28' AS last_day UNION Select      '2017-03-01' AS first_day,      '2017-03-31' AS last_day), cross_join AS  (SELECT * FROM subscriptions  Cross JOIN months ),status AS(Select id, first_day AS month, CASE      WHEN (subscription_start < first_day) AND         (subscription_end >   first_day OR subscription_end IS NULL) AND (segment = 87) THEN 1      ELSE 0 END AS is_active_87,  CASE      WHEN (subscription_start < first_day) AND (subscription_end > first_day OR subscription_end IS NULL) AND (segment = 30) Then 1      ELSE 0 END AS is_active_30, CASE      WHEN (subscription_end BETWEEN first_day AND last_day)      AND (segment = 87) Then 1     ELSE 0END AS is_canceled_87,CASE      WHEN (subscription_end BETWEEN first_day AND last_day) AND (segment = 30) Then 1     ELSE 0END AS is_canceled_30From cross_join ), status_aggregate AS (SELECT    month,  SUM(is_active_87) AS sum_active_87,  SUM(is_active_30) AS sum_active_30,  SUM(is_canceled_87) AS sum_canceled_87,  SUM(is_canceled_30) AS sum_canceled_30  FROM status   Group BY month  )   Select month,1.0 * sum_canceled_87/sum_active_87 AS churn_rate_87,1.0 * sum_canceled_30/sum_active_30 AS churn_rate_30 From status_aggregate;Query 8 Results: monthchurn_rate_87churn_rate_302017-01-010.2517985611510790.07560137457044672017-02-010.320346320346320.07335907335907342017-03-010.4858757062146890.11731843575419